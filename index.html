<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Compressor Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <style>
        #cropOverlay {
            pointer-events: none;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.3);
            border: 2px dashed #fff;
        }
        .loader {
            border-top-color: #3B82F6;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #passwordPopup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 1000;
        }
        #overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
        }
    </style>
</head>
<body class="bg-gray-100">
    <!-- Password Popup -->
    <div id="overlay"></div>
    <div id="passwordPopup" class="bg-white rounded-lg shadow-lg">
        <div class="flex justify-between items-center mb-4">
            <h2 class="text-lg font-semibold">üîí Password Required</h2>
            <button id="closePopup" class="text-gray-500 hover:text-gray-700">&times;</button>
        </div>
        <input type="password" id="passwordInput" placeholder="Enter PDF password" 
               class="w-full p-2 border rounded-md mb-4">
        <button id="submitPassword" class="w-full px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">
            Submit
        </button>
    </div>

    <!-- Main Container -->
    <div class="container mx-auto p-6">
        <!-- File Upload -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-6">
            <div id="dropZone" class="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center cursor-pointer">
                <p class="text-gray-500">üìÅ Drag & drop a PDF file or <span class="text-blue-600">click to upload</span></p>
                <input type="file" id="pdfInput" accept="application/pdf" class="hidden">
            </div>
        </div>

        <!-- Controls -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-6 grid grid-cols-1 md:grid-cols-4 gap-6">
            <div>
                <label class="block text-sm font-medium text-gray-700 mb-2">Quality</label>
                <input type="range" id="qualitySlider" min="1" max="100" value="85" 
                       class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                <span id="qualityValue" class="text-sm text-gray-600">85%</span>
            </div>

            <div>
                <label class="block text-sm font-medium text-gray-700 mb-2">DPI</label>
                <select id="dpiSelect" class="w-full p-2 border rounded-md">
                    <option value="72">72 DPI</option>
                    <option value="96">96 DPI</option>
                    <option value="120">120 DPI</option>
                    <option value="150">150 DPI</option>
                    <option value="200">200 DPI</option>
                    <option value="250">250 DPI</option>
                </select>
            </div>

            <div>
                <label class="block text-sm font-medium text-gray-700 mb-2">Target Size</label>
                <select id="sizePreset" class="w-full p-2 border rounded-md">
                    <option value="0">Custom</option>
                    <option value="50">50KB</option>
                    <option value="80">80KB</option>
                    <option value="100">100KB</option>
                    <option value="150">150KB</option>
                    <option value="200">200KB</option>
                    <option value="300">300KB</option>
                </select>
            </div>

            <div>
                <label class="block text-sm font-medium text-gray-700 mb-2">Estimated Size</label>
                <div id="sizePreview" class="text-sm text-gray-600">0 KB</div>
            </div>
        </div>

        <!-- Preview Section -->
        <div class="bg-white rounded-lg shadow-md p-6">
            <div class="relative border-2 border-dashed border-gray-300 rounded-lg overflow-hidden">
                <canvas id="pdfCanvas" class="w-full"></canvas>
                <div id="cropOverlay" class="absolute hidden"></div>
                <div id="loading" class="absolute inset-0 bg-gray-200 bg-opacity-75 hidden">
                    <div class="flex items-center justify-center h-full">
                        <div class="loader h-12 w-12 border-4 rounded-full"></div>
                        <div id="compressionStatus" class="ml-4 text-gray-700"></div>
                    </div>
                </div>
            </div>
            
            <div class="mt-4 flex justify-between items-center">
                <button id="prevPage" class="px-4 py-2 bg-gray-200 rounded-md hover:bg-gray-300">Previous</button>
                <span id="pageInfo" class="text-sm text-gray-600">Page 1/1</span>
                <button id="nextPage" class="px-4 py-2 bg-gray-200 rounded-md hover:bg-gray-300">Next</button>
            </div>
            
            <button id="downloadBtn" class="mt-4 w-full px-6 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors">
                Start Compression
            </button>
        </div>
    </div>

<script>
// Global Variables
const canvas = document.getElementById('pdfCanvas');
const ctx = canvas.getContext('2d');
const cropOverlay = document.getElementById('cropOverlay');
let pdfDoc = null;
let currentPage = 1;
let totalPages = 1;
let isDragging = false;
let startX = 0, startY = 0, cropX = 0, cropY = 0, cropWidth = 0, cropHeight = 0;
let passwordCache = null;
let originalPdfBuffer = null;

// Password Popup Handling
const passwordPopup = document.getElementById('passwordPopup');
const overlay = document.getElementById('overlay');
const passwordInput = document.getElementById('passwordInput');
const submitPassword = document.getElementById('submitPassword');
const closePopup = document.getElementById('closePopup');

function showPasswordPopup() {
    passwordPopup.style.display = 'block';
    overlay.style.display = 'block';
}

function hidePasswordPopup() {
    passwordPopup.style.display = 'none';
    overlay.style.display = 'none';
}

closePopup.addEventListener('click', hidePasswordPopup);
overlay.addEventListener('click', hidePasswordPopup);

// Drag and Drop File Upload
const dropZone = document.getElementById('dropZone');
const pdfInput = document.getElementById('pdfInput');

dropZone.addEventListener('click', () => pdfInput.click());
pdfInput.addEventListener('change', handleFileUpload);

dropZone.addEventListener('dragover', (e) => {
    e.preventDefault();
    dropZone.classList.add('border-blue-600');
});

dropZone.addEventListener('dragleave', () => {
    dropZone.classList.remove('border-blue-600');
});

dropZone.addEventListener('drop', (e) => {
    e.preventDefault();
    dropZone.classList.remove('border-blue-600');
    if (e.dataTransfer.files.length > 0) {
        pdfInput.files = e.dataTransfer.files;
        handleFileUpload();
    }
});

// File Upload Handler
async function handleFileUpload() {
    const file = pdfInput.files[0];
    if (!file) return;
    
    showLoading('Loading PDF...');
    passwordCache = null;
    try {
        originalPdfBuffer = await file.arrayBuffer();
        pdfDoc = await loadPDFWithPassword(originalPdfBuffer);
        totalPages = pdfDoc.numPages;
        currentPage = 1;
        updatePageInfo();
        await renderPage(currentPage);
        updateSizeEstimate();
    } catch (error) {
        showError(error.message);
    }
    hideLoading();
}

// Password Handling
async function loadPDFWithPassword(arrayBuffer) {
    try {
        const bufferCopy = arrayBuffer.slice(0);
        const loadingTask = pdfjsLib.getDocument({
            data: new Uint8Array(bufferCopy),
            password: passwordCache
        });
        return await loadingTask.promise;
    } catch (error) {
        if (error.name === 'PasswordException') {
            showPasswordPopup();
            passwordCache = await new Promise((resolve) => {
                submitPassword.addEventListener('click', () => {
                    resolve(passwordInput.value);
                    hidePasswordPopup();
                }, { once: true });
            });
            if (!passwordCache) throw new Error('Password required');
            return loadPDFWithPassword(arrayBuffer);
        }
        throw error;
    }
}

// Page Rendering
async function renderPage(pageNumber) {
    if (!pdfDoc) return;
    
    showLoading('Rendering page...');
    try {
        const page = await pdfDoc.getPage(pageNumber);
        const viewport = page.getViewport({ scale: 1 });
        
        canvas.height = viewport.height;
        canvas.width = viewport.width;
        
        await page.render({
            canvasContext: ctx,
            viewport: viewport
        }).promise;
    } catch (error) {
        showError('Page render failed: ' + error.message);
    }
    hideLoading();
}

// Compression Algorithm
async function adaptiveCompressionLoop(targetKB) {
    let quality = 85;
    let dpi = 250;
    const dpiSteps = [250, 200, 150, 120, 96, 72];
    
    for (const currentDPI of dpiSteps) {
        let currentQuality = 95;
        while (currentQuality >= 10) {
            const estimate = await calculateSizeEstimate(currentQuality, currentDPI);
            if (estimate <= targetKB) {
                return { quality: currentQuality, dpi: currentDPI };
            }
            currentQuality -= 5;
        }
    }
    return { quality: 30, dpi: 72 };
}

// Size Estimation
async function calculateSizeEstimate(quality, dpi) {
    if (!pdfDoc) return 0;
    
    try {
        const page = await pdfDoc.getPage(currentPage);
        const viewport = page.getViewport({ scale: 1 });
        const scale = dpi / 72;
        
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = (cropWidth || viewport.width) * scale;
        tempCanvas.height = (cropHeight || viewport.height) * scale;
        
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(canvas, 
            cropX || 0, cropY || 0, 
            cropWidth || viewport.width, 
            cropHeight || viewport.height,
            0, 0, tempCanvas.width, tempCanvas.height
        );
        
        return new Promise(resolve => {
            tempCanvas.toBlob(blob => {
                const avgSizeKB = Math.round(blob.size / 1024);
                resolve(avgSizeKB * totalPages);
            }, 'image/jpeg', quality/100);
        });
    } catch (error) {
        showError('Size calculation failed');
        return 0;
    }
}

// Compression and Download
document.getElementById('downloadBtn').addEventListener('click', async () => {
    if (!pdfDoc) {
        showWarning('Please upload a PDF first!');
        return;
    }
    
    const targetKB = parseInt(document.getElementById('sizePreset').value) || 100;
    if (targetKB > 0 && targetKB < 50) {
        showWarning('Target sizes below 50KB may result in poor quality');
        return;
    }

    showLoading('Optimizing settings...');
    try {
        const { quality, dpi } = targetKB > 0 ? 
            await adaptiveCompressionLoop(targetKB) : 
            { quality: document.getElementById('qualitySlider').value, 
              dpi: document.getElementById('dpiSelect').value };

        await compressAndDownload(quality, dpi);
    } catch (error) {
        showError('Compression failed: ' + error.message);
    }
    hideLoading();
});

async function compressAndDownload(quality, dpi) {
    const { PDFDocument } = PDFLib;
    const newPdf = await PDFDocument.create();
    
    for (let i = 1; i <= totalPages; i++) {
        updateStatus(`Processing page ${i}/${totalPages}`);
        const page = await pdfDoc.getPage(i);
        const viewport = page.getViewport({ scale: 1 });
        
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        const scaleFactor = dpi / 72;
        
        tempCanvas.width = (cropWidth || viewport.width) * scaleFactor;
        tempCanvas.height = (cropHeight || viewport.height) * scaleFactor;
        
        await page.render({
            canvasContext: tempCtx,
            viewport: page.getViewport({ scale: scaleFactor })
        }).promise;

        if (cropWidth > 0 && cropHeight > 0) {
            const croppedCanvas = document.createElement('canvas');
            const croppedCtx = croppedCanvas.getContext('2d');
            croppedCanvas.width = cropWidth * scaleFactor;
            croppedCanvas.height = cropHeight * scaleFactor;
            
            croppedCtx.drawImage(
                tempCanvas,
                cropX * scaleFactor, 
                cropY * scaleFactor,
                croppedCanvas.width,
                croppedCanvas.height,
                0, 0,
                croppedCanvas.width,
                croppedCanvas.height
            );
            
            tempCanvas.width = croppedCanvas.width;
            tempCanvas.height = croppedCanvas.height;
            tempCtx.drawImage(croppedCanvas, 0, 0);
        }

        const jpegUrl = await new Promise(resolve => {
            tempCanvas.toBlob(blob => resolve(URL.createObjectURL(blob)), 'image/jpeg', quality/100);
        });

        const jpegImage = await newPdf.embedJpg(await fetch(jpegUrl).then(r => r.arrayBuffer()));
        const newPage = newPdf.addPage([jpegImage.width, jpegImage.height]);
        newPage.drawImage(jpegImage, {
            x: 0,
            y: 0,
            width: jpegImage.width,
            height: jpegImage.height
        });

        URL.revokeObjectURL(jpegUrl);
    }

    const pdfBytes = await newPdf.save();
    const blob = new Blob([pdfBytes], { type: 'application/pdf' });
    const link = document.createElement('a');
    link.download = `compressed-${Date.now()}.pdf`;
    link.href = URL.createObjectURL(blob);
    link.click();
    URL.revokeObjectURL(link.href);
}

// UI Helpers
function updatePageInfo() {
    document.getElementById('pageInfo').textContent = `Page ${currentPage}/${totalPages}`;
}

function showLoading(message = '') {
    document.getElementById('loading').style.display = 'block';
    document.getElementById('compressionStatus').textContent = message;
}

function hideLoading() {
    document.getElementById('loading').style.display = 'none';
}

function updateStatus(message) {
    document.getElementById('compressionStatus').textContent = message;
}

function showError(message) {
    alert('Error: ' + message);
}

function showWarning(message) {
    alert('Warning: ' + message);
}

// Page Navigation
document.getElementById('prevPage').addEventListener('click', async () => {
    if (currentPage > 1) {
        currentPage--;
        updatePageInfo();
        await renderPage(currentPage);
        updateSizeEstimate();
    }
});

document.getElementById('nextPage').addEventListener('click', async () => {
    if (currentPage < totalPages) {
        currentPage++;
        updatePageInfo();
        await renderPage(currentPage);
        updateSizeEstimate();
    }
});

// Crop Functionality
canvas.addEventListener('mousedown', (e) => {
    isDragging = true;
    const rect = canvas.getBoundingClientRect();
    startX = e.clientX - rect.left;
    startY = e.clientY - rect.top;
    cropX = startX;
    cropY = startY;
    cropOverlay.style.display = 'block';
});

canvas.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    const rect = canvas.getBoundingClientRect();
    const currentX = e.clientX - rect.left;
    const currentY = e.clientY - rect.top;
    
    cropWidth = currentX - startX;
    cropHeight = currentY - startY;
    
    cropOverlay.style.left = `${Math.min(startX, currentX)}px`;
    cropOverlay.style.top = `${Math.min(startY, currentY)}px`;
    cropOverlay.style.width = `${Math.abs(cropWidth)}px`;
    cropOverlay.style.height = `${Math.abs(cropHeight)}px`;
});

canvas.addEventListener('mouseup', () => {
    isDragging = false;
    updateSizeEstimate();
});

// Auto-Update Handlers
let estimationTimeout;
document.getElementById('sizePreset').addEventListener('change', updateSizeEstimate);
document.getElementById('qualitySlider').addEventListener('input', function() {
    document.getElementById('qualityValue').textContent = `${this.value}%`;
    document.getElementById('sizePreset').value = '0';
    updateSizeEstimate();
});

document.getElementById('dpiSelect').addEventListener('change', () => {
    document.getElementById('sizePreset').value = '0';
    updateSizeEstimate();
});

async function updateSizeEstimate() {
    clearTimeout(estimationTimeout);
    estimationTimeout = setTimeout(async () => {
        const targetKB = parseInt(document.getElementById('sizePreset').value);
        if (targetKB > 0) {
            showLoading('Optimizing settings...');
            const { quality, dpi } = await adaptiveCompressionLoop(targetKB);
            document.getElementById('qualitySlider').value = quality;
            document.getElementById('dpiSelect').value = dpi;
            document.getElementById('qualityValue').textContent = `${quality}%`;
            hideLoading();
        }
        refreshSizeDisplay();
    }, 500);
}

async function refreshSizeDisplay() {
    if (!pdfDoc) return;
    const quality = parseInt(document.getElementById('qualitySlider').value);
    const dpi = parseInt(document.getElementById('dpiSelect').value);
    const estimate = await calculateSizeEstimate(quality, dpi);
    document.getElementById('sizePreview').textContent = `${estimate} KB`;
}
</script>
</body>
</html>